import Mathlib.Topology.Basic
import Mathlib.Topology.Instances.Int
import Mathlib.Topology.MetricSpace.Basic
import Mathlib.Data.Int.ModEq
import Mathlib.Data.Nat.Prime
import Mathlib.Algebra.Order.Floor

/-!
# Furstenberg's Topology and the Infinitude of Primes

This file formalizes Furstenberg's topological proof of the infinitude of primes.
We define a topology on ℤ based on arithmetic progressions (residue classes)
and use topological properties to prove that there are infinitely many primes.

## Main results

* `arithProg`: Definition of arithmetic progressions on integers
* `FurstenbergTopology`: The topology generated by arithmetic progressions
* `infinite_primes`: The infinitude of primes using topological arguments

## References

* H. Furstenberg, "On the infinitude of primes", Amer. Math. Monthly 62 (1955)
-/

/-- An arithmetic progression with start `a` and period `b` -/
def arithProg (a : ℤ) (b : ℕ) : Set ℤ :=
  {x : ℤ | x ≡ a [ZMOD b]}

namespace ArithProg

lemma mem_iff {a : ℤ} {b : ℕ} {x : ℤ} :
    x ∈ arithProg a b ↔ x ≡ a [ZMOD b] := Iff.rfl

lemma arithProg_zero_right (a : ℤ) : arithProg a 0 = {a} := by
  ext x
  simp [arithProg, Int.modEq_iff_dvd]

lemma arithProg_one_right (a : ℤ) : arithProg a 1 = Set.univ := by
  ext x
  simp [arithProg]
  exact Int.modEq_one x a

lemma arithProg_disjoint {a a' : ℤ} {b : ℕ}
    (h_neq : ¬(a ≡ a' [ZMOD b])) (hb : 0 < b) :
    arithProg a b ∩ arithProg a' b = ∅ := by
  ext x
  simp [arithProg]
  intro h1 h2
  exact h_neq (Int.ModEq.trans h1.symm h2)

lemma arithProg_dvd_mono {a : ℤ} {b b' : ℕ} (h : b ∣ b') :
    arithProg a b' ⊆ arithProg a b := by
  intro x hx
  simp [arithProg] at hx ⊢
  exact Int.ModEq.of_dvd h hx

lemma infinite_arithProg {a : ℤ} {b : ℕ} (hb : 0 < b) :
    Set.Infinite (arithProg a b) := by
  intro h_fin
  -- The map n ↦ a + b*n is injective
  have inj : Function.Injective (fun (n : ℤ) => a + ↑b * n) := by
    intro n m h
    have : (b : ℤ) * n = (b : ℤ) * m := by linarith
    exact Int.eq_of_mul_eq_mul_left (Int.coe_nat_pos.mpr hb) this
  -- And its range is the arithmetic progression
  have range_eq : Set.range (fun (n : ℤ) => a + ↑b * n) = arithProg a b := by
    ext x
    constructor
    · intro ⟨n, hn⟩
      simp [arithProg, hn]
      use n
      ring
    · intro hx
      simp [arithProg] at hx
      obtain ⟨k, hk⟩ := hx
      use k
      linarith
  -- This gives a contradiction
  rw [← range_eq] at h_fin
  exact Set.infinite_univ (Set.Infinite.of_injective_image inj h_fin)

end ArithProg

/-- The Furstenberg topology on ℤ -/
structure FurstenbergTopology where
  isOpen : Set ℤ → Prop
  isOpen_univ : isOpen Set.univ
  isOpen_inter : ∀ s t, isOpen s → isOpen t → isOpen (s ∩ t)
  isOpen_sUnion : ∀ S, (∀ s ∈ S, isOpen s) → isOpen (⋃₀ S)
  isOpen_def : ∀ U, isOpen U ↔
    ∀ x ∈ U, ∃ b > 0, arithProg x b ⊆ U

namespace FurstenbergTopology

/-- The standard Furstenberg topology instance -/
def standard : FurstenbergTopology where
  isOpen U := ∀ x ∈ U, ∃ b > 0, arithProg x b ⊆ U
  isOpen_univ := by simp
  isOpen_inter := by
    intro s t hs ht x ⟨hxs, hxt⟩
    obtain ⟨b1, hb1, h1⟩ := hs x hxs
    obtain ⟨b2, hb2, h2⟩ := ht x hxt
    use Nat.lcm b1 b2
    constructor
    · exact Nat.lcm_pos hb1 hb2
    · intro y hy
      constructor
      · apply h1
        exact ArithProg.arithProg_dvd_mono (Nat.dvd_lcm_left b1 b2) hy
      · apply h2
        exact ArithProg.arithProg_dvd_mono (Nat.dvd_lcm_right b1 b2) hy
  isOpen_sUnion := by
    intro S hS x ⟨U, hU_in, hx⟩
    obtain ⟨b, hb, h_sub⟩ := hS U hU_in x hx
    use b, hb
    intro y hy
    exact ⟨U, hU_in, h_sub hy⟩
  isOpen_def := by intro; rfl

/-- Arithmetic progressions are open -/
lemma isOpen_arithProg (a : ℤ) (b : ℕ) (hb : 0 < b) :
    standard.isOpen (arithProg a b) := by
  intro x hx
  use b, hb
  intro y hy
  simp [arithProg] at hx hy ⊢
  exact Int.ModEq.trans hx.symm hy

/-- Arithmetic progressions are closed -/
lemma isClosed_arithProg (a : ℤ) (b : ℕ) (hb : 0 < b) :
    standard.isOpen (arithProg a b)ᶜ := by
  intro x hx
  simp [arithProg] at hx
  -- The complement is a union of other arithmetic progressions
  use b, hb
  intro y hy
  simp [arithProg] at hy ⊢
  intro h_contra
  apply hx
  exact Int.ModEq.trans hy.symm h_contra

/-- Non-empty open sets are infinite -/
lemma isOpen_infinite {U : Set ℤ} (h_open : standard.isOpen U)
    (h_nonempty : U.Nonempty) : Set.Infinite U := by
  obtain ⟨x, hx⟩ := h_nonempty
  obtain ⟨b, hb, h_sub⟩ := h_open x hx
  exact Set.Infinite.mono h_sub (ArithProg.infinite_arithProg hb)

end FurstenbergTopology

/-- The main theorem: there are infinitely many primes -/
theorem infinite_primes : Set.Infinite {p : ℕ | Nat.Prime p} := by
  by_contra h_fin
  -- If finitely many primes, consider the union of all arithmetic progressions
  -- of multiples of primes
  let A := ⋃ p ∈ {p : ℕ | Nat.Prime p}, arithProg (0 : ℤ) p

  -- This set is closed (finite union of closed sets)
  have hA_closed : FurstenbergTopology.standard.isOpen Aᶜ := by
    have : FurstenbergTopology.standard.isOpen A := by
      apply FurstenbergTopology.standard.isOpen_sUnion
      intro s ⟨p, hp, hs⟩
      rw [← hs]
      exact FurstenbergTopology.isOpen_arithProg 0 p (Nat.Prime.pos hp)
    sorry -- Would need to show complement of open is closed

  -- A is exactly ℤ \ {1, -1}
  have hA_eq : A = {1, -1}ᶜ := by
    ext n
    constructor
    · intro ⟨p, hp_prime, hn⟩
      simp [arithProg] at hn
      intro h_contra
      cases h_contra with
      | inl h1 =>
        rw [h1] at hn
        have : (p : ℤ) ∣ 1 := by
          obtain ⟨k, hk⟩ := hn
          use k
          linarith
        have : p ∣ 1 := Int.coe_nat_dvd.mp this
        exact Nat.Prime.not_dvd_one hp_prime this
      | inr h_neg1 =>
        rw [h_neg1] at hn
        have : (p : ℤ) ∣ -1 := by
          obtain ⟨k, hk⟩ := hn
          use -k
          linarith
        have : p ∣ 1 := by
          have := Int.dvd_nat_abs.mp this
          simp at this
          exact this
        exact Nat.Prime.not_dvd_one hp_prime this
    · intro hn
      simp at hn
      by_cases h0 : n = 0
      · use 2, Nat.prime_two
        simp [arithProg, h0]
      · -- Any non-zero integer other than ±1 has a prime divisor
        have : ∃ p, Nat.Prime p ∧ (p : ℤ) ∣ n := by
          have h_abs : 1 < n.natAbs := by
            by_contra h_le
            interval_cases n.natAbs
            · exact h0 (Int.natAbs_eq_zero.mp rfl)
            · cases hn
              · exact absurd (Int.natAbs_eq_iff.mp ‹_›).1 ‹_›
              · exact absurd (Int.natAbs_eq_iff.mp ‹_›).2 ‹_›
          obtain ⟨p, hp_prime, hp_dvd⟩ := Nat.exists_prime_and_dvd h_abs
          use p, hp_prime
          exact Int.coe_nat_dvd.mpr (Int.dvd_natAbs.mpr hp_dvd)
        obtain ⟨p, hp_prime, hp_dvd⟩ := this
        use p, hp_prime
        simp [arithProg]
        obtain ⟨k, hk⟩ := hp_dvd
        use k
        exact hk.symm

  -- But {1, -1} is finite, so not open, contradiction
  have h_not_open : ¬FurstenbergTopology.standard.isOpen {1, -1} := by
    intro h_open
    have h_inf := FurstenbergTopology.isOpen_infinite h_open ⟨1, Or.inl rfl⟩
    exact h_inf (Set.finite_singleton 1 |>.union (Set.finite_singleton (-1)))

  -- Aᶜ = {1, -1} is open, contradiction
  rw [hA_eq] at hA_closed
  exact h_not_open hA_closed

#check infinite_primes
